//! `lazypaw init` â€” interactive project initialization.

use crate::config::AppConfig;
use crate::pool::Pool;
use crate::schema;
use std::io::{self, Write};

pub struct InitArgs {
    pub server: Option<String>,
    pub database: Option<String>,
    pub user: Option<String>,
    pub password: Option<String>,
    pub port: u16,
    pub trust_cert: bool,
    pub lang: Option<String>,
    pub output: String,
}

fn prompt(label: &str, default: &str) -> String {
    if default.is_empty() {
        print!("{}: ", label);
    } else {
        print!("{} [{}]: ", label, default);
    }
    io::stdout().flush().unwrap();
    let mut buf = String::new();
    io::stdin().read_line(&mut buf).unwrap();
    let trimmed = buf.trim();
    if trimmed.is_empty() {
        default.to_string()
    } else {
        trimmed.to_string()
    }
}

pub async fn run_init(args: InitArgs) -> Result<(), Box<dyn std::error::Error>> {
    println!("ðŸ¾ lazypaw init\n");

    // 1. Gather connection info
    let server = args.server.unwrap_or_else(|| prompt("Server", "localhost"));
    let database = args.database.unwrap_or_else(|| prompt("Database", ""));
    let user = args.user.unwrap_or_else(|| prompt("User", "sa"));
    let password = args.password.unwrap_or_else(|| prompt("Password", ""));
    let port = args.port;
    let trust_cert = args.trust_cert;

    if database.is_empty() {
        eprintln!("Error: database name is required");
        std::process::exit(1);
    }

    // 2. Test connection
    print!("Testing connection to {}...", server);
    io::stdout().flush().unwrap();

    let config = AppConfig {
        server: server.clone(),
        port: 1433,
        user: user.clone(),
        password: password.clone(),
        database: Some(database.clone()),
        listen_port: port,
        default_schema: "dbo".to_string(),
        jwt_secret: None,
        anon_role: None,
        pool_size: 2,
        trust_cert,
        schemas: None,
        auth_mode: crate::config::AuthMode::None,
        oidc_issuer: None,
        oidc_audience: None,
        role_claim: "role".to_string(),
        context_claims: Vec::new(),
        role_map: std::collections::HashMap::new(),
        db_auth: crate::config::DbAuthMode::Password,
        sp_tenant_id: None,
        sp_client_id: None,
        sp_client_secret: None,
        realtime: false,
        realtime_poll_ms: 200,
        log_level: "info".to_string(),
        log_format: "text".to_string(),
        log_slow_queries: None,
        otel_enabled: false,
        otel_endpoint: String::new(),
        otel_service_name: "lazypaw".to_string(),
    };

    let pool = Pool::new(config.clone());

    // Test connectivity
    {
        let mut conn = pool
            .get()
            .await
            .map_err(|e| format!(" âœ—\nConnection failed: {}", e))?;
        let client = conn.client();
        let stream = client
            .execute("SELECT 1 AS ok", &[])
            .await
            .map_err(|e| format!(" âœ—\nConnection failed: {}", e))?;
        let _ = stream
            .into_first_result()
            .await
            .map_err(|e| format!(" âœ—\nConnection failed: {}", e))?;
    }
    println!(" âœ“");

    // 3. Introspect schema
    print!("Loading schema...");
    io::stdout().flush().unwrap();
    let schema_cache = schema::load_schema(&pool).await?;
    let table_count = schema_cache.tables.values().filter(|t| !t.is_view).count();
    let view_count = schema_cache.tables.values().filter(|t| t.is_view).count();
    println!(" âœ“ ({} tables, {} views)", table_count, view_count);

    // 4. Generate config file
    let toml_content = format!(
        r#"# lazypaw configuration
# Generated by lazypaw init

[database]
server = "{server}"
database = "{database}"
user = "{user}"
# password = "..." # Set via LAZYPAW_PASSWORD env var
trust_cert = {trust_cert}

[server]
port = {port}
"#,
        server = server,
        database = database,
        user = user,
        trust_cert = trust_cert,
        port = port,
    );

    std::fs::write(&args.output, &toml_content)?;
    println!("Config written to {}", args.output);

    // 5. Run codegen if --lang provided
    if let Some(ref lang) = args.lang {
        let output_file = match lang.as_str() {
            "typescript" | "ts" => "./src/db-types.ts".to_string(),
            "python" | "py" => "./src/db_types.py".to_string(),
            _ => format!("./db-types.{}", lang),
        };
        let content = match lang.as_str() {
            "typescript" | "ts" => crate::codegen::generate_typescript(&schema_cache, &database),
            "python" | "py" => crate::codegen::generate_python(&schema_cache, &database),
            other => {
                eprintln!(
                    "Unsupported language: {}. Use 'typescript' or 'python'.",
                    other
                );
                std::process::exit(1);
            }
        };
        std::fs::write(&output_file, &content)?;
        println!("Generated {} â†’ {}", lang, output_file);
    }

    // 6. Print summary
    println!();
    println!("âœ¨ lazypaw initialized!");
    println!();
    println!("  Config:    {}", args.output);
    println!(
        "  Database:  {} ({} tables, {} views)",
        database, table_count, view_count
    );
    println!();
    println!("  Start the server:");
    println!(
        "    lazypaw --config {} --password $LAZYPAW_PASSWORD",
        args.output
    );
    println!();
    println!("  Generate types:");
    println!("    lazypaw codegen --lang typescript --output ./src/db-types.ts");
    println!();
    println!("  API:       http://localhost:{}", port);
    println!("  Swagger:   http://localhost:{}/swagger", port);
    println!();
    println!("  ðŸ’¡ Set your password via: export LAZYPAW_PASSWORD='...'");

    Ok(())
}
