//! lazypaw â€” CLI entry point.
//!
//! Parses CLI args, loads config, connects to SQL Server,
//! introspects the schema, and launches the axum HTTP server.
//! Handles SIGHUP for live schema reload.

mod auth;
mod config;
mod error;
mod filters;
mod handlers;
mod openapi;
mod pool;
mod query;
mod realtime;
mod realtime_ws;
mod response;
mod router;
mod schema;
mod select;
mod types;

use clap::Parser;
use config::{AppConfig, Args, SubCommand};
use handlers::AppState;
use pool::Pool;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing_subscriber::EnvFilter;

fn run_setup(roles: &str, service_account: &str) {
    let roles: Vec<&str> = roles.split(',').map(|s| s.trim()).collect();

    println!("-- ============================================");
    println!("-- lazypaw setup script");
    println!("-- Generated by: lazypaw setup");
    println!("-- ============================================");
    println!();
    println!("-- 1. Create service account");
    println!("CREATE USER [{}] WITHOUT LOGIN;", service_account);
    println!();
    println!("-- 2. Create roles (WITHOUT LOGIN)");
    for role in &roles {
        println!("CREATE USER [{}] WITHOUT LOGIN;", role);
    }
    println!();
    println!("-- 3. Grant schema introspection to service account");
    println!(
        "GRANT SELECT ON INFORMATION_SCHEMA.TABLES TO [{}];",
        service_account
    );
    println!(
        "GRANT SELECT ON INFORMATION_SCHEMA.COLUMNS TO [{}];",
        service_account
    );
    println!(
        "GRANT SELECT ON INFORMATION_SCHEMA.KEY_COLUMN_USAGE TO [{}];",
        service_account
    );
    println!(
        "GRANT SELECT ON INFORMATION_SCHEMA.TABLE_CONSTRAINTS TO [{}];",
        service_account
    );
    println!(
        "GRANT SELECT ON INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS TO [{}];",
        service_account
    );
    println!("GRANT VIEW DEFINITION TO [{}];", service_account);
    println!();
    println!("-- 4. Grant IMPERSONATE for each role to service account");
    for role in &roles {
        println!(
            "GRANT IMPERSONATE ON USER::[{}] TO [{}];",
            role, service_account
        );
    }
    println!();
    println!("-- 5. Template GRANT statements per role");
    println!("-- Customize these for your schema:");
    for role in &roles {
        println!("-- GRANT SELECT ON SCHEMA::dbo TO [{}];", role);
        println!(
            "-- GRANT INSERT, UPDATE, DELETE ON SCHEMA::dbo TO [{}];",
            role
        );
    }
    println!();
    println!("-- 6. Template RLS policy");
    println!("-- Example row-level security using session context:");
    println!("/*");
    println!("CREATE FUNCTION dbo.fn_rls_filter(@tenant_id NVARCHAR(128))");
    println!("RETURNS TABLE");
    println!("WITH SCHEMABINDING");
    println!("AS");
    println!("RETURN SELECT 1 AS result");
    println!("  WHERE @tenant_id = CONVERT(NVARCHAR(128),");
    println!("    SESSION_CONTEXT(N'request.jwt.claim.sub'));");
    println!();
    println!("CREATE SECURITY POLICY dbo.TenantFilter");
    println!("  ADD FILTER PREDICATE dbo.fn_rls_filter(tenant_id) ON dbo.my_table,");
    println!("  ADD BLOCK PREDICATE dbo.fn_rls_filter(tenant_id) ON dbo.my_table;");
    println!("*/");
    println!();
    println!("-- 7. Template session context helper function");
    println!("/*");
    println!("CREATE OR ALTER FUNCTION dbo.fn_current_user_id()");
    println!("RETURNS NVARCHAR(128)");
    println!("AS");
    println!("BEGIN");
    println!("  RETURN CONVERT(NVARCHAR(128), SESSION_CONTEXT(N'request.jwt.claim.sub'));");
    println!("END;");
    println!("*/");
    println!();
    println!("-- Done! Review and execute this script against your database.");
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let args = Args::parse();

    // Handle setup subcommand before initializing tracing/DB
    if let Some(SubCommand::Setup {
        roles,
        service_account,
    }) = &args.subcmd
    {
        run_setup(roles, service_account);
        return Ok(());
    }

    // â”€â”€ Tracing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| EnvFilter::new("lazypaw=info,tower_http=info")),
        )
        .init();

    let config = AppConfig::from_args(args);

    tracing::info!(
        "ðŸ˜´ lazypaw starting â€” {}:{} db={:?}",
        config.server,
        config.port,
        config.database
    );

    // â”€â”€ Connection pool â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let pool = Pool::new(config.clone());

    // Verify connectivity
    {
        tracing::info!("Testing database connection...");
        let mut conn = pool.get().await?;
        let client = conn.client();
        let stream = client
            .execute("SELECT 1 AS ok", &[])
            .await
            .map_err(|e| format!("Connection test failed: {}", e))?;
        let _ = stream
            .into_first_result()
            .await
            .map_err(|e| format!("Connection test failed: {}", e))?;
        tracing::info!("Database connection verified âœ“");
    }

    // â”€â”€ Schema introspection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    tracing::info!("Loading schema...");
    let schema_cache = schema::load_schema(&pool).await?;
    let table_count = schema_cache.tables.len();
    let schema = Arc::new(RwLock::new(schema_cache));
    tracing::info!("Schema loaded: {} tables/views âœ“", table_count);

    // â”€â”€ Build app state & router â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let state = AppState {
        pool: pool.clone(),
        schema: schema.clone(),
        config: config.clone(),
    };

    // â”€â”€ Realtime engine (optional) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let engine = if config.realtime {
        tracing::info!("Realtime enabled â€” initializing Change Tracking poller...");
        let engine = realtime::RealtimeEngine::new(pool.clone(), schema.clone(), config.clone());
        if let Err(e) = engine.init_version().await {
            tracing::warn!("Realtime CT version init failed (non-fatal): {}", e);
        }
        let poll_engine = engine.clone();
        let poll_ms = config.realtime_poll_ms;
        tokio::spawn(async move {
            poll_engine.poll_loop(poll_ms).await;
        });
        tracing::info!(
            "Realtime poller started (poll_ms={})",
            config.realtime_poll_ms
        );
        Some(engine)
    } else {
        None
    };

    let app = router::build_router(state, engine);

    // â”€â”€ SIGHUP handler for schema reload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    #[cfg(unix)]
    {
        let sighup_pool = pool.clone();
        let sighup_schema = schema.clone();
        tokio::spawn(async move {
            use tokio::signal::unix::{signal, SignalKind};
            let mut hup = signal(SignalKind::hangup()).expect("failed to register SIGHUP handler");
            loop {
                hup.recv().await;
                tracing::info!("SIGHUP received â€” reloading schema...");
                match schema::load_schema(&sighup_pool).await {
                    Ok(new_cache) => {
                        let mut w = sighup_schema.write().await;
                        *w = new_cache;
                        tracing::info!("Schema reloaded âœ“");
                    }
                    Err(e) => {
                        tracing::error!("Schema reload failed: {}", e);
                    }
                }
            }
        });
    }

    // â”€â”€ Start HTTP server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let listen_addr = format!("0.0.0.0:{}", config.listen_port);
    let listener = tokio::net::TcpListener::bind(&listen_addr).await?;
    tracing::info!("Listening on http://{}", listen_addr);
    tracing::info!("OpenAPI spec â†’ http://localhost:{}/", config.listen_port);
    tracing::info!(
        "Swagger UI   â†’ http://localhost:{}/swagger",
        config.listen_port
    );

    axum::serve(listener, app).await?;

    Ok(())
}
