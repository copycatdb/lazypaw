//! Code generation: TypeScript and Python typed clients from schema.

use crate::schema::{ColumnInfo, SchemaCache};
use chrono::Utc;

fn ts_type(sql_type: &str) -> &'static str {
    match sql_type.to_lowercase().as_str() {
        "int" | "smallint" | "tinyint" | "bigint" | "float" | "real" | "decimal" | "numeric"
        | "money" | "smallmoney" => "number",
        "bit" => "boolean",
        "nvarchar" | "varchar" | "char" | "nchar" | "text" | "ntext" | "datetime" | "datetime2"
        | "date" | "time" | "smalldatetime" | "datetimeoffset" | "uniqueidentifier"
        | "varbinary" | "binary" | "image" | "xml" => "string",
        _ => "unknown",
    }
}

fn py_type(sql_type: &str) -> &'static str {
    match sql_type.to_lowercase().as_str() {
        "int" | "smallint" | "tinyint" | "bigint" => "int",
        "float" | "real" | "decimal" | "numeric" | "money" | "smallmoney" => "float",
        "bit" => "bool",
        "nvarchar" | "varchar" | "char" | "nchar" | "text" | "ntext" | "uniqueidentifier" => "str",
        "datetime" | "datetime2" | "datetimeoffset" => "datetime",
        "date" => "date",
        "time" => "time",
        "varbinary" | "binary" | "image" => "bytes",
        _ => "Any",
    }
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|w| {
            let mut c = w.chars();
            match c.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().to_string() + &c.as_str().to_lowercase(),
            }
        })
        .collect()
}

pub fn generate_typescript(schema: &SchemaCache, db_name: &str) -> String {
    let now = Utc::now().format("%Y-%m-%dT%H:%M:%SZ");
    let mut out = String::new();
    out.push_str(&format!(
        "// AUTO-GENERATED by lazypaw codegen\n// Database: {} | Generated: {}\n// Do not edit manually â€” re-run: lazypaw codegen --lang typescript\n\n",
        db_name, now
    ));
    out.push_str("export interface Database {\n");

    let mut tables: Vec<_> = schema.tables.values().filter(|t| !t.is_view).collect();
    tables.sort_by(|a, b| a.name.cmp(&b.name));

    for table in &tables {
        out.push_str(&format!("  {}: {{\n", table.name));

        // Row
        out.push_str("    Row: {\n");
        for col in &table.columns {
            let t = ts_type(&col.data_type);
            let null_suffix = if col.is_nullable { " | null" } else { "" };
            out.push_str(&format!("      {}: {}{}\n", col.name, t, null_suffix));
        }
        out.push_str("    }\n");

        // Insert
        out.push_str("    Insert: {\n");
        for col in &table.columns {
            if col.is_identity {
                out.push_str(&format!(
                    "      // {}: auto-generated (IDENTITY)\n",
                    col.name
                ));
                continue;
            }
            if col.is_computed {
                out.push_str(&format!("      // {}: computed column\n", col.name));
                continue;
            }
            let t = ts_type(&col.data_type);
            let optional = col.has_default || col.is_nullable;
            if optional {
                let reason = if col.has_default {
                    " // has DEFAULT"
                } else {
                    " // nullable"
                };
                out.push_str(&format!("      {}?: {}{}\n", col.name, t, reason));
            } else {
                out.push_str(&format!("      {}: {}\n", col.name, t));
            }
        }
        out.push_str("    }\n");

        // Update
        out.push_str("    Update: {\n");
        for col in &table.columns {
            if col.is_identity || col.is_computed {
                continue;
            }
            let t = ts_type(&col.data_type);
            out.push_str(&format!("      {}?: {}\n", col.name, t));
        }
        out.push_str("    }\n");

        out.push_str("  }\n");
    }

    out.push_str("}\n");
    out
}

pub fn generate_python(schema: &SchemaCache, db_name: &str) -> String {
    let now = Utc::now().format("%Y-%m-%dT%H:%M:%SZ");
    let mut out = String::new();
    out.push_str(&format!(
        "# AUTO-GENERATED by lazypaw codegen\n# Database: {} | Generated: {}\n\n",
        db_name, now
    ));
    out.push_str("from __future__ import annotations\nfrom pydantic import BaseModel\nfrom datetime import datetime, date, time\nfrom typing import Any, Optional\n\n");

    let mut tables: Vec<_> = schema.tables.values().filter(|t| !t.is_view).collect();
    tables.sort_by(|a, b| a.name.cmp(&b.name));

    // Check which types are actually used
    let needs_any = tables
        .iter()
        .any(|t| t.columns.iter().any(|c| py_type(&c.data_type) == "Any"));
    let _ = needs_any; // imports are always included for simplicity

    for table in &tables {
        let pascal = to_pascal_case(&table.name);

        // Row
        out.push_str(&format!("class {}Row(BaseModel):\n", pascal));
        for col in &table.columns {
            let t = py_type(&col.data_type);
            if col.is_nullable {
                out.push_str(&format!("    {}: Optional[{}] = None\n", col.name, t));
            } else {
                out.push_str(&format!("    {}: {}\n", col.name, t));
            }
        }
        out.push('\n');

        // Insert
        out.push_str(&format!("class {}Insert(BaseModel):\n", pascal));
        let insert_cols: Vec<&ColumnInfo> = table
            .columns
            .iter()
            .filter(|c| !c.is_identity && !c.is_computed)
            .collect();
        if insert_cols.is_empty() {
            out.push_str("    pass\n");
        } else {
            // Required fields first, then optional
            let mut required: Vec<&ColumnInfo> = Vec::new();
            let mut optional: Vec<&ColumnInfo> = Vec::new();
            for col in &insert_cols {
                if col.has_default || col.is_nullable {
                    optional.push(col);
                } else {
                    required.push(col);
                }
            }
            for col in &required {
                out.push_str(&format!("    {}: {}\n", col.name, py_type(&col.data_type)));
            }
            for col in &optional {
                let t = py_type(&col.data_type);
                out.push_str(&format!("    {}: Optional[{}] = None\n", col.name, t));
            }
        }
        out.push('\n');

        // Update
        out.push_str(&format!("class {}Update(BaseModel):\n", pascal));
        let update_cols: Vec<&ColumnInfo> = table
            .columns
            .iter()
            .filter(|c| !c.is_identity && !c.is_computed)
            .collect();
        if update_cols.is_empty() {
            out.push_str("    pass\n");
        } else {
            for col in &update_cols {
                let t = py_type(&col.data_type);
                out.push_str(&format!("    {}: Optional[{}] = None\n", col.name, t));
            }
        }
        out.push('\n');
    }

    out
}
